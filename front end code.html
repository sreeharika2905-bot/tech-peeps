<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>StudyMate â€” PDF Q&A (Frontend Only)</title>
  <!-- Tailwind CSS (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- PDF.js (CDN) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <style>
    html,body{height:100%} .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}
    .card{border-radius:1rem; box-shadow:0 8px 30px rgba(0,0,0,.08)}
    .spinner{border:4px solid #e5e7eb;border-top-color:#6366f1;border-radius:50%;width:22px;height:22px;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body class="bg-slate-50 text-slate-900">
  <div class="max-w-6xl mx-auto p-4 md:p-8">
    <header class="mb-6">
      <h1 class="text-3xl md:text-4xl font-bold">ðŸ“š StudyMate</h1>
      <p class="text-slate-600">AI-style study helper (browser-only demo): upload a PDF, ask questions, get extractive answers with citations, summaries & quick quizzes.</p>
    </header>

    <section class="grid md:grid-cols-3 gap-6">
      <!-- Left: Controls -->
      <div class="md:col-span-1 space-y-6">
        <div class="card bg-white p-5">
          <h2 class="font-semibold mb-3">Upload PDF</h2>
          <input id="pdfInput" type="file" accept="application/pdf" class="block w-full rounded-lg border border-slate-300 p-2" />
          <div class="text-sm text-slate-500 mt-2">All processing happens locally in your browser.</div>
          <div id="loadStatus" class="text-sm text-indigo-600 mt-3"></div>
        </div>

        <div class="card bg-white p-5">
          <h2 class="font-semibold mb-3">Settings</h2>
          <label class="block text-sm mb-1">Chunk size (words)</label>
          <input id="chunkSize" type="range" min="200" max="900" value="600" step="50" class="w-full">
          <div class="text-sm text-slate-600"><span id="chunkSizeVal">600</span> words</div>

          <label class="block text-sm mt-4 mb-1">Overlap (words)</label>
          <input id="overlap" type="range" min="0" max="200" value="80" step="10" class="w-full">
          <div class="text-sm text-slate-600"><span id="overlapVal">80</span> words</div>

          <label class="block text-sm mt-4 mb-1">Retrieved chunks</label>
          <input id="topK" type="number" min="1" max="10" value="5" class="w-24 border rounded p-1">
        </div>

        <div class="card bg-white p-5">
          <h2 class="font-semibold mb-3">Quick Actions</h2>
          <button id="summBtn" class="w-full bg-indigo-600 text-white rounded-xl py-2.5 hover:bg-indigo-700">Generate 5-bullet Summary</button>
          <div class="mt-3 flex items-center gap-2">
            <input id="quizN" type="number" min="1" max="10" value="3" class="w-20 border rounded p-1">
            <button id="quizBtn" class="flex-1 bg-slate-900 text-white rounded-xl py-2.5 hover:bg-black">Create Quiz</button>
          </div>
        </div>
      </div>

      <!-- Right: QA + Output -->
      <div class="md:col-span-2 space-y-6">
        <div class="card bg-white p-5">
          <h2 class="font-semibold mb-3">Ask a question</h2>
          <div class="flex gap-2">
            <input id="question" class="flex-1 border rounded-xl px-3 py-2" placeholder="e.g., What is photosynthesis?" />
            <button id="askBtn" class="bg-indigo-600 text-white rounded-xl px-4 py-2 hover:bg-indigo-700">Ask</button>
          </div>
          <div id="thinking" class="hidden mt-3 flex items-center gap-2"><div class="spinner"></div><span>Thinkingâ€¦</span></div>
          <div id="answerWrap" class="mt-4 hidden">
            <h3 class="font-semibold">Answer</h3>
            <div id="answer" class="mt-2 leading-relaxed"></div>
            <details class="mt-3">
              <summary class="cursor-pointer text-sm text-slate-600">Show retrieved context (citations)</summary>
              <pre id="context" class="mt-2 bg-slate-50 border rounded p-3 whitespace-pre-wrap mono"></pre>
            </details>
          </div>
        </div>

        <div class="card bg-white p-5">
          <h2 class="font-semibold mb-3">Summary</h2>
          <div id="summary" class="text-slate-700"></div>
        </div>

        <div class="card bg-white p-5">
          <h2 class="font-semibold mb-3">Quiz</h2>
          <div id="quiz" class="space-y-4"></div>
        </div>
      </div>
    </section>

    <footer class="text-sm text-slate-500 mt-8">
      Frontend-only demo using PDF.js + TF-IDF retrieval & extractive answering. For true generative answers, connect a backend LLM (IBM watsonx, etc.).
    </footer>
  </div>

  <script>
    // ---------- UI refs ----------
    const pdfInput = document.getElementById("pdfInput");
    const loadStatus = document.getElementById("loadStatus");
    const chunkSizeEl = document.getElementById("chunkSize");
    const chunkSizeVal = document.getElementById("chunkSizeVal");
    const overlapEl = document.getElementById("overlap");
    const overlapVal = document.getElementById("overlapVal");
    const topKEl = document.getElementById("topK");

    const askBtn = document.getElementById("askBtn");
    const questionEl = document.getElementById("question");
    const thinking = document.getElementById("thinking");
    const answerWrap = document.getElementById("answerWrap");
    const answerEl = document.getElementById("answer");
    const contextEl = document.getElementById("context");

    const summBtn = document.getElementById("summBtn");
    const summaryEl = document.getElementById("summary");
    const quizBtn = document.getElementById("quizBtn");
    const quizNEl = document.getElementById("quizN");
    const quizEl = document.getElementById("quiz");

    // ---------- State ----------
    let PAGES = [];          // [{page: 1, text: "..."}]
    let CHUNKS = [];         // ["text", ...]
    let PAGE_MAP = [];       // chunk index -> page number
    let TFIDF = null;        // { vocab, idf, docs: [{tf}] }

    // ---------- Helpers ----------
    function cleanText(t) {
      return (t || "")
        .replace(/\u0000/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function tokenize(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, " ")
        .split(/\s+/)
        .filter(w => w && w.length > 1);
    }

    function buildChunks(fullText, size=600, overlap=80) {
      const words = fullText.split(/\s+/);
      const chunks = [];
      let i = 0;
      while (i < words.length) {
        const chunk = words.slice(i, i + size).join(" ");
        chunks.push(chunk);
        i += Math.max(1, size - overlap);
      }
      return chunks;
    }

    function mapChunksToPages(pages, chunks, overlap) {
      // Rough mapping by word counts
      const pageWordCounts = pages.map(p => p.text.split(/\s+/).length);
      const cumulative = [];
      pageWordCounts.reduce((acc, n, idx) => (cumulative[idx] = acc + n, acc + n), 0);

      const starts = [];
      let wordsSoFar = 0;
      for (const ch of chunks) {
        starts.push(wordsSoFar);
        wordsSoFar += ch.split(/\s+/).length - overlap;
      }
      return starts.map(st => {
        let pg = cumulative.findIndex(c => st < c) + 1;
        if (pg < 1) pg = 1;
        if (pg > pages.length) pg = pages.length;
        return pg;
      });
    }

    function computeTFIDF(docs) {
      const vocab = new Map();
      const dfs = new Map();
      const tokenized = docs.map(d => tokenize(d));

      // build vocab + document frequencies
      tokenized.forEach(tokens => {
        const seen = new Set();
        tokens.forEach(w => {
          if (!vocab.has(w)) vocab.set(w, vocab.size);
          if (!seen.has(w)) {
            dfs.set(w, (dfs.get(w) || 0) + 1);
            seen.add(w);
          }
        });
      });

      const N = docs.length;
      const idf = new Float32Array(vocab.size);
      for (const [w, idx] of vocab.entries()) {
        const df = dfs.get(w) || 1;
        idf[idx] = Math.log((N + 1) / (df + 1)) + 1; // smoothed
      }

      // compute tf vectors per doc (sparse as Map)
      const docTF = tokenized.map(tokens => {
        const tf = new Map();
        tokens.forEach(w => {
          const idx = vocab.get(w);
          tf.set(idx, (tf.get(idx) || 0) + 1);
        });
        // normalize by length
        const len = tokens.length || 1;
        for (const [k, v] of tf.entries()) tf.set(k, v / len);
        return tf;
      });

      return { vocab, idf, docs: docTF };
    }

    function cosineSimSparse(tf_a, tf_b, idf) {
      // dot product
      let dot = 0, na = 0, nb = 0;
      tf_a.forEach((va, k) => {
        const w = idf[k];
        na += (va*w)*(va*w);
        if (tf_b.has(k)) dot += (va*w) * (tf_b.get(k)*w);
      });
      tf_b.forEach((vb, k) => {
        const w = idf[k];
        nb += (vb*w)*(vb*w);
      });
      const denom = (Math.sqrt(na) * Math.sqrt(nb)) || 1e-8;
      return dot / denom;
    }

    function rankChunks(query, topK=5) {
      if (!TFIDF) return [];
      const { vocab, idf, docs } = TFIDF;
      const qtf = new Map();
      tokenize(query).forEach(w => {
        if (vocab.has(w)) {
          const idx = vocab.get(w);
          qtf.set(idx, (qtf.get(idx) || 0) + 1);
        }
      });
      // normalize
      const qlen = [...qtf.values()].reduce((a,b)=>a+b,0) || 1;
      for (const [k,v] of qtf.entries()) qtf.set(k, v/qlen);

      const scored = docs.map((tf, i) => ({ i, score: cosineSimSparse(qtf, tf, idf) }));
      scored.sort((a,b) => b.score - a.score);
      return scored.slice(0, topK);
    }

    function bestSentences(text, query, limit=3) {
      const sents = text.split(/(?<=[.!?])\s+/);
      const qTokens = new Set(tokenize(query));
      const scored = sents.map(s => {
        const tokens = tokenize(s);
        // simple overlap score + length prior
        let overlap = 0;
        tokens.forEach(t => { if (qTokens.has(t)) overlap++; });
        const score = overlap / Math.sqrt(tokens.length + 1);
        return { s, score };
      });
      scored.sort((a,b)=>b.score-a.score);
      return scored.slice(0, limit).map(x=>x.s);
    }

    function summarize(text, n=5) {
      const sents = text.split(/(?<=[.!?])\s+/).filter(Boolean);
      if (sents.length <= n) return sents;
      // frequency-based summary
      const freq = new Map();
      tokenize(text).forEach(w => freq.set(w, (freq.get(w)||0)+1));
      const scored = sents.map(s=>{
        const tokens = tokenize(s);
        const score = tokens.reduce((acc,t)=>acc+(freq.get(t)||0),0) / Math.sqrt(tokens.length+1);
        return { s, score };
      });
      scored.sort((a,b)=>b.score-a.score);
      return scored.slice(0,n).map(x=>x.s);
    }

    function quizFromText(text, n=3) {
      const sents = text.split(/(?<=[.!?])\s+/).filter(s => s.split(" ").length > 6);
      const selected = [];
      for (let i=0; i<sents.length && selected.length<n; i++){
        const words = sents[i].split(/\s+/);
        // choose a "key" word: longest non-stopword
        const candidates = words
          .map(w => w.replace(/[^A-Za-z]/g,''))
          .filter(w => w.length >= 5 && !STOPWORDS.has(w.toLowerCase()));
        if (!candidates.length) continue;
        const key = candidates.sort((a,b)=>b.length-a.length)[0];
        const stem = key;
        const blanked = sents[i].replace(new RegExp("\\b"+stem+"\\b","i"), "_");
        // options: correct + 3 distractors (nearby length words)
        const dict = words
          .map(w => w.replace(/[^A-Za-z]/g,''))
          .filter(w => w && w.toLowerCase()!==key.toLowerCase());
        const pool = Array.from(new Set(dict)).filter(w=>Math.abs(w.length-key.length)<=2 && !STOPWORDS.has(w.toLowerCase()));
        while (pool.length < 3) pool.push(key + Math.random().toString(36).slice(2,3)); // fallback
        const opts = shuffle([key, ...shuffle(pool).slice(0,3)]).slice(0,4);
        const letters = ["A","B","C","D"];
        const correctIdx = opts.findIndex(o => o.toLowerCase() === key.toLowerCase());
        selected.push({
          q: blanked,
          options: opts.map((o,i)=>({label: letters[i], text:o})),
          answer: letters[correctIdx]
        });
      }
      return selected;
    }

    const STOPWORDS = new Set(("a,an,the,and,or,if,then,than,that,this,these,those,of,to,in,on,for,with,as,by,at,from,is,are,was,were,be,been,being,it,its,into,about,over,under,between,after,before,not,no,so,such,can,could,should,would,may,might,do,does,did,done,have,has,had,you,your,they,them,he,she,we,us,our"
      ).split(","));

    function shuffle(arr){ return arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]); }

    // ---------- PDF loading ----------
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

    async function extractPDF(file) {
      const buf = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
      PAGES = [];
      loadStatus.textContent = Loaded ${pdf.numPages} pages. Extracting textâ€¦;
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        const strings = content.items.map(it => it.str).join(" ");
        PAGES.push({ page: i, text: cleanText(strings) });
        loadStatus.textContent = Extractingâ€¦ ${i}/${pdf.numPages};
        await new Promise(r=>setTimeout(r,0)); // yield
      }
      loadStatus.textContent = Text extracted from ${pdf.numPages} pages. Building indexâ€¦;
      buildIndex();
    }

    function buildIndex() {
      const size = parseInt(chunkSizeEl.value, 10);
      const ov = parseInt(overlapEl.value, 10);
      const fullText = PAGES.map(p=>p.text).join(" ");
      CHUNKS = buildChunks(fullText, size, ov);
      PAGE_MAP = mapChunksToPages(PAGES, CHUNKS, ov);
      TFIDF = computeTFIDF(CHUNKS);
      loadStatus.textContent = Index ready: ${CHUNKS.length} chunks.;
    }

    // ---------- Events ----------
    pdfInput.addEventListener("change", e => {
      const f = e.target.files?.[0];
      if (!f) return;
      extractPDF(f);
    });

    chunkSizeEl.addEventListener("input", () => {
      chunkSizeVal.textContent = chunkSizeEl.value;
    });
    overlapEl.addEventListener("input", () => {
      overlapVal.textContent = overlapEl.value;
    });

    askBtn.addEventListener("click", () => {
      const q = questionEl.value.trim();
      if (!q) return alert("Enter a question.");
      if (!TFIDF) return alert("Upload a PDF first.");
      thinking.classList.remove("hidden");
      answerWrap.classList.add("hidden");
      setTimeout(()=> {
        const topK = Math.max(1, Math.min(10, parseInt(topKEl.value||"5",10)));
        const ranked = rankChunks(q, topK);
        const ctxBlocks = ranked.map(r => [Page ${PAGE_MAP[r.i]} | score ${r.score.toFixed(3)}]\n${CHUNKS[r.i]});
        const ctx = ctxBlocks.join("\n\n");
        // "Answer" = top sentences from top chunk(s)
        const combined = ranked.slice(0, Math.min(3, ranked.length))
          .map(r=>CHUNKS[r.i]).join(" ");
        const sentences = bestSentences(combined, q, 4);
        const pretty = sentences.length ? sentences.join(" ") : "I couldn't find a confident answer in the document.";
        answerEl.textContent = pretty;
        contextEl.textContent = ctx;
        thinking.classList.add("hidden");
        answerWrap.classList.remove("hidden");
      }, 50);
    });

    summBtn.addEventListener("click", ()=>{
      if (!CHUNKS.length) return alert("Upload a PDF first.");
      const sample = CHUNKS.slice(0, 6).join(" ");
      const bullets = summarize(sample, 5);
      summaryEl.innerHTML = "<ul class='list-disc pl-6 space-y-1'>" +
        bullets.map(b=><li>${b}</li>).join("") + "</ul>";
    });

    quizBtn.addEventListener("click", ()=>{
      if (!CHUNKS.length) return alert("Upload a PDF first.");
      const n = Math.max(1, Math.min(10, parseInt(quizNEl.value||"3",10)));
      const sample = CHUNKS.slice(0, 8).join(" ");
      const qs = quizFromText(sample, n);
      if (!qs.length) { quizEl.textContent = "Could not generate quiz. Try another document."; return; }
      quizEl.innerHTML = qs.map((q,i)=>`
        <div class="border rounded-xl p-3">
          <div class="font-medium mb-2">Q${i+1}. ${q.q}</div>
          <div class="grid sm:grid-cols-2 gap-2">
            ${q.options.map(o=>`
              <label class="flex items-center gap-2 border rounded-lg p-2">
                <input type="radio" name="q_${i}" value="${o.label}">
                <span>${o.label}) ${o.text}</span>
              </label>
            `).join("")}
          </div>
          <div class="text-sm text-slate-600 mt-2">Answer: <span class="font-semibold">${q.answer}</span></div>
        </div>
      `).join("");
    });
  </script>
</body>
</html>